/*
 * Copyright (C) 1997-2001 Id Software, Inc.
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * 
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package lwjake2.game.monsters;

import lwjake2.Defines;
import lwjake2.game.EntDieAdapter;
import lwjake2.game.EntPainAdapter;
import lwjake2.game.EntThinkAdapter;
import lwjake2.game.EntTouchAdapter;
import lwjake2.game.EntUseAdapter;
import lwjake2.game.GameAI;
import lwjake2.game.GameBase;
import lwjake2.game.GameMisc;
import lwjake2.game.GameUtil;
import lwjake2.game.Monster;
import lwjake2.game.cplane_t;
import lwjake2.game.csurface_t;
import lwjake2.game.edict_t;
import lwjake2.game.mframe_t;
import lwjake2.game.mmove_t;
import lwjake2.util.Lib;
import lwjake2.util.Math3D;

public class M_Actor {
    //    This file generated by ModelGen - Do NOT Modify

    public final static int FRAME_attak01 = 0;

    public final static int FRAME_attak04 = 3;

    public final static int FRAME_death101 = 4;

    public final static int FRAME_death106 = 9;

    public final static int FRAME_death107 = 10;

    public final static int FRAME_death201 = 11;

    public final static int FRAME_death213 = 23;

    public final static int FRAME_flip01 = 39;

    public final static int FRAME_flip14 = 52;

    public final static int FRAME_pain101 = 74;

    public final static int FRAME_pain102 = 75;

    public final static int FRAME_pain103 = 76;

    public final static int FRAME_pain201 = 77;

    public final static int FRAME_pain202 = 78;

    public final static int FRAME_pain203 = 79;

    public final static int FRAME_pain301 = 80;

    public final static int FRAME_pain302 = 81;

    public final static int FRAME_pain303 = 82;

    public final static int FRAME_run02 = 93;

    public final static int FRAME_run07 = 98;

    public final static int FRAME_stand101 = 128;

    public final static int FRAME_stand140 = 167;

    public final static int FRAME_taunt01 = 234;

    public final static int FRAME_taunt17 = 250;

    public final static int FRAME_walk01 = 251;

    public final static int FRAME_walk08 = 258;

    public final static int FRAME_walk10 = 260;

    public final static int FRAME_walk11 = 261;

    public final static float MODEL_SCALE = 1.000000f;

    public final static int MAX_ACTOR_NAMES = 8;

    static String actor_names[] = { "Hellrot", "Tokay", "Killme", "Disruptor",
            "Adrianator", "Rambear", "Titus", "Bitterman" };

    static EntThinkAdapter actor_stand = new EntThinkAdapter() {
        public String getID() { return "actor_stand";}
        public boolean think(edict_t self) {
            self.monsterinfo.currentmove = actor_move_stand;

            // randomize on startup
            if (GameBase.level.time < 1.0)
                self.s.frame = self.monsterinfo.currentmove.firstframe
                        + (Lib.rand() % (self.monsterinfo.currentmove.lastframe
                                - self.monsterinfo.currentmove.firstframe + 1));
            return true;
        }
    };

    static mframe_t actor_frames_stand[] = new mframe_t[] {
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null),
            new mframe_t(GameAI.ai_stand, 0f, null) };

    static mmove_t actor_move_stand = new mmove_t(FRAME_stand101,
            FRAME_stand140, actor_frames_stand, null);

    static mframe_t actor_frames_walk[] = {
            new mframe_t(GameAI.ai_walk, 0, null),
            new mframe_t(GameAI.ai_walk, 6, null),
            new mframe_t(GameAI.ai_walk, 10, null),
            new mframe_t(GameAI.ai_walk, 3, null),
            new mframe_t(GameAI.ai_walk, 2, null),
            new mframe_t(GameAI.ai_walk, 7, null),
            new mframe_t(GameAI.ai_walk, 10, null),
            new mframe_t(GameAI.ai_walk, 1, null),
            new mframe_t(GameAI.ai_walk, 4, null),
            new mframe_t(GameAI.ai_walk, 0, null),
            new mframe_t(GameAI.ai_walk, 0, null) };

    static mmove_t actor_move_walk = new mmove_t(FRAME_walk01, FRAME_walk08,
            actor_frames_walk, null);

    static EntThinkAdapter actor_walk = new EntThinkAdapter() {
        public String getID() { return "actor_walk";}
        public boolean think(edict_t self) {
            self.monsterinfo.currentmove = actor_move_walk;
            return true;
        }
    };

    static mframe_t actor_frames_run[] = new mframe_t[] {
            new mframe_t(GameAI.ai_run, 4, null),
            new mframe_t(GameAI.ai_run, 15, null),
            new mframe_t(GameAI.ai_run, 15, null),
            new mframe_t(GameAI.ai_run, 8, null),
            new mframe_t(GameAI.ai_run, 20, null),
            new mframe_t(GameAI.ai_run, 15, null),
            new mframe_t(GameAI.ai_run, 8, null),
            new mframe_t(GameAI.ai_run, 17, null),
            new mframe_t(GameAI.ai_run, 12, null),
            new mframe_t(GameAI.ai_run, -2, null),
            new mframe_t(GameAI.ai_run, -2, null),
            new mframe_t(GameAI.ai_run, -1, null) };

    static mmove_t actor_move_run = new mmove_t(FRAME_run02, FRAME_run07,
            actor_frames_run, null);

    static EntThinkAdapter actor_run = new EntThinkAdapter() {
        public String getID() { return "actor_run";}
        public boolean think(edict_t self) {
            if ((GameBase.level.time < self.pain_debounce_time)
                    && (self.enemy == null)) {
                if (self.movetarget != null)
                    actor_walk.think(self);
                else
                    actor_stand.think(self);
                return true;
            }

            if ((self.monsterinfo.aiflags & Defines.AI_STAND_GROUND) != 0) {
                actor_stand.think(self);
                return true;
            }

            self.monsterinfo.currentmove = actor_move_run;
            return true;

        }
    };

    static mframe_t actor_frames_pain1[] = new mframe_t[] {
            new mframe_t(GameAI.ai_move, -5, null),
            new mframe_t(GameAI.ai_move, 4, null),
            new mframe_t(GameAI.ai_move, 1, null) };

    static mmove_t actor_move_pain1 = new mmove_t(FRAME_pain101, FRAME_pain103,
            actor_frames_pain1, actor_run);

    static mframe_t actor_frames_pain2[] = new mframe_t[] {
            new mframe_t(GameAI.ai_move, -4, null),
            new mframe_t(GameAI.ai_move, 4, null),
            new mframe_t(GameAI.ai_move, 0, null) };

    static mmove_t actor_move_pain2 = new mmove_t(FRAME_pain201, FRAME_pain203,
            actor_frames_pain2, actor_run);

    static mframe_t actor_frames_pain3[] = new mframe_t[] {
            new mframe_t(GameAI.ai_move, -1, null),
            new mframe_t(GameAI.ai_move, 1, null),
            new mframe_t(GameAI.ai_move, 0, null) };

    static mmove_t actor_move_pain3 = new mmove_t(FRAME_pain301, FRAME_pain303,
            actor_frames_pain3, actor_run);

    static mframe_t actor_frames_flipoff[] = new mframe_t[] {
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null) };

    static mmove_t actor_move_flipoff = new mmove_t(FRAME_flip01, FRAME_flip14,
            actor_frames_flipoff, actor_run);

    static mframe_t actor_frames_taunt[] = new mframe_t[] {
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null),
            new mframe_t(GameAI.ai_turn, 0, null) };

    static mmove_t actor_move_taunt = new mmove_t(FRAME_taunt01, FRAME_taunt17,
            actor_frames_taunt, actor_run);

    static String messages[] = { "Watch it", "#$@*&", "Idiot",
            "Check your targets" };

    static EntPainAdapter actor_pain = new EntPainAdapter() {
        public String getID() { return "actor_pain";}
        public void pain(edict_t self, edict_t other, float kick, int damage) {

            int n;

            if (self.health < (self.max_health / 2))
                self.s.skinnum = 1;

            if (GameBase.level.time < self.pain_debounce_time)
                return;

            self.pain_debounce_time = GameBase.level.time + 3;
            //GameBase.gi.sound (self, CHAN_VOICE, actor.sound_pain, 1,
            // ATTN_NORM, 0);

            if ((other.client != null) && (Lib.random() < 0.4)) {
                float v[] = { 0, 0, 0 };

                String name;

                Math3D.VectorSubtract(other.s.origin, self.s.origin, v);
                self.ideal_yaw = Math3D.vectoyaw(v);
                if (Lib.random() < 0.5f)
                    self.monsterinfo.currentmove = actor_move_flipoff;
                else
                    self.monsterinfo.currentmove = actor_move_taunt;

                // FIXME: does the ent-id work out ?
                name = actor_names[(self.index) % MAX_ACTOR_NAMES];

                GameBase.gi.cprintf(other, Defines.PRINT_CHAT, name + ": "
                        + messages[Lib.rand() % 3] + "!\n");
                return;
            }

            n = Lib.rand() % 3;
            if (n == 0)
                self.monsterinfo.currentmove = actor_move_pain1;
            else if (n == 1)
                self.monsterinfo.currentmove = actor_move_pain2;
            else
                self.monsterinfo.currentmove = actor_move_pain3;
        }
    };

    static EntThinkAdapter actor_dead = new EntThinkAdapter() {
        public String getID() { return "actor_dead";}
        public boolean think(edict_t self) {
            Math3D.VectorSet(self.mins, -16, -16, -24);
            Math3D.VectorSet(self.maxs, 16, 16, -8);
            self.movetype = Defines.MOVETYPE_TOSS;
            self.svflags |= Defines.SVF_DEADMONSTER;
            self.nextthink = 0;
            GameBase.gi.linkentity(self);
            return true;
        }
    };

    static mframe_t actor_frames_death1[] = new mframe_t[] {
            new mframe_t(GameAI.ai_move, 0, null),
            new mframe_t(GameAI.ai_move, 0, null),
            new mframe_t(GameAI.ai_move, -13, null),
            new mframe_t(GameAI.ai_move, 14, null),
            new mframe_t(GameAI.ai_move, 3, null),
            new mframe_t(GameAI.ai_move, -2, null),
            new mframe_t(GameAI.ai_move, 1, null) };

    static mmove_t actor_move_death1 = new mmove_t(FRAME_death101,
            FRAME_death107, actor_frames_death1, actor_dead);

    static mframe_t actor_frames_death2[] = new mframe_t[] {
            new mframe_t(GameAI.ai_move, 0, null),
            new mframe_t(GameAI.ai_move, 7, null),
            new mframe_t(GameAI.ai_move, -6, null),
            new mframe_t(GameAI.ai_move, -5, null),
            new mframe_t(GameAI.ai_move, 1, null),
            new mframe_t(GameAI.ai_move, 0, null),
            new mframe_t(GameAI.ai_move, -1, null),
            new mframe_t(GameAI.ai_move, -2, null),
            new mframe_t(GameAI.ai_move, -1, null),
            new mframe_t(GameAI.ai_move, -9, null),
            new mframe_t(GameAI.ai_move, -13, null),
            new mframe_t(GameAI.ai_move, -13, null),
            new mframe_t(GameAI.ai_move, 0, null) };

    static mmove_t actor_move_death2 = new mmove_t(FRAME_death201,
            FRAME_death213, actor_frames_death2, actor_dead);

    static EntDieAdapter actor_die = new EntDieAdapter() {
        public String getID() { return "actor_die";}
        public void die(edict_t self, edict_t inflictor, edict_t attacker,
                int damage, float[] point) {
            int n;

            //    check for gib
            if (self.health <= -80) {
                //         gi.sound (self, CHAN_VOICE, actor.sound_gib, 1, ATTN_NORM,
                // 0);
                for (n = 0; n < 2; n++)
                    GameMisc.ThrowGib(self, "models/objects/gibs/bone/tris.md2",
                            damage, Defines.GIB_ORGANIC);
                for (n = 0; n < 4; n++)
                    GameMisc.ThrowGib(self,
                            "models/objects/gibs/sm_meat/tris.md2", damage,
                            Defines.GIB_ORGANIC);
                GameMisc.ThrowHead(self, "models/objects/gibs/head2/tris.md2",
                        damage, Defines.GIB_ORGANIC);
                self.deadflag = Defines.DEAD_DEAD;
                return;
            }

            if (self.deadflag == Defines.DEAD_DEAD)
                return;

            //    regular death
            //     gi.sound (self, CHAN_VOICE, actor.sound_die, 1, ATTN_NORM, 0);
            self.deadflag = Defines.DEAD_DEAD;
            self.takedamage = Defines.DAMAGE_YES;

            n = Lib.rand() % 2;
            if (n == 0)
                self.monsterinfo.currentmove = actor_move_death1;
            else
                self.monsterinfo.currentmove = actor_move_death2;
        }
    };

    static EntThinkAdapter actor_fire = new EntThinkAdapter() {
        public String getID() { return "actor_fire";}
        public boolean think(edict_t self) {
            actorMachineGun(self);

            if (GameBase.level.time >= self.monsterinfo.pausetime)
                self.monsterinfo.aiflags &= ~Defines.AI_HOLD_FRAME;
            else
                self.monsterinfo.aiflags |= Defines.AI_HOLD_FRAME;

            return true;
        }
    };

    static mframe_t actor_frames_attack[] = new mframe_t[] {
            new mframe_t(GameAI.ai_charge, -2, actor_fire),
            new mframe_t(GameAI.ai_charge, -2, null),
            new mframe_t(GameAI.ai_charge, 3, null),
            new mframe_t(GameAI.ai_charge, 2, null) };

    static mmove_t actor_move_attack = new mmove_t(FRAME_attak01,
            FRAME_attak04, actor_frames_attack, actor_run);

    static EntThinkAdapter actor_attack = new EntThinkAdapter() {
        public String getID() { return "actor_attack";}
        public boolean think(edict_t self) {
            int n;

            self.monsterinfo.currentmove = actor_move_attack;
            n = (Lib.rand() & 15) + 3 + 7;
            self.monsterinfo.pausetime = GameBase.level.time + n
                    * Defines.FRAMETIME;

            return true;
        }
    };

    static EntUseAdapter actor_use = new EntUseAdapter() {
        public String getID() { return "actor_use";}
        public void use(edict_t self, edict_t other, edict_t activator) {
            float v[] = { 0, 0, 0 };

            self.goalentity = self.movetarget = GameBase
                    .G_PickTarget(self.target);
            if ((null == self.movetarget)
                    || (Lib.strcmp(self.movetarget.classname, "target_actor") != 0)) {
                GameBase.gi
                        .dprintf(self.classname + " has bad target "
                                + self.target + " at "
                                + Lib.vtos(self.s.origin) + "\n");
                self.target = null;
                self.monsterinfo.pausetime = 100000000;
                self.monsterinfo.stand.think(self);
                return;
            }

            Math3D.VectorSubtract(self.goalentity.s.origin, self.s.origin, v);
            self.ideal_yaw = self.s.angles[Defines.YAW] = Math3D.vectoyaw(v);
            self.monsterinfo.walk.think(self);
            self.target = null;
        }
    };

    /*
     * QUAKED target_actor (.5 .3 0) (-8 -8 -8) (8 8 8) JUMP SHOOT ATTACK x HOLD
     * BRUTAL JUMP jump in set direction upon reaching this target SHOOT take a
     * single shot at the pathtarget ATTACK attack pathtarget until it or actor
     * is dead
     * 
     * "target" next target_actor "pathtarget" target of any action to be taken
     * at this point "wait" amount of time actor should pause at this point
     * "message" actor will "say" this to the player
     * 
     * for JUMP only: "speed" speed thrown forward (default 200) "height" speed
     * thrown upwards (default 200)
     */

    static EntTouchAdapter target_actor_touch = new EntTouchAdapter() {
        public String getID() { return "target_actor_touch";}
        public void touch(edict_t self, edict_t other, cplane_t plane,
                csurface_t surf) {
            float v[] = { 0, 0, 0 };

            if (other.movetarget != self)
                return;

            if (other.enemy != null)
                return;

            other.goalentity = other.movetarget = null;

            if (self.message != null) {
                int n;
                edict_t ent;

                for (n = 1; n <= GameBase.game.maxclients; n++) {
                    ent = GameBase.g_edicts[n];
                    if (!ent.inuse)
                        continue;
                    GameBase.gi.cprintf(ent, Defines.PRINT_CHAT,
                            actor_names[(other.index) % MAX_ACTOR_NAMES] + ": "
                                    + self.message + "\n");
                }
            }

            if ((self.spawnflags & 1) != 0) //jump
            {
                other.velocity[0] = self.movedir[0] * self.speed;
                other.velocity[1] = self.movedir[1] * self.speed;

                if (other.groundentity != null) {
                    other.groundentity = null;
                    other.velocity[2] = self.movedir[2];
                    GameBase.gi.sound(other, Defines.CHAN_VOICE, GameBase.gi
                            .soundindex("player/male/jump1.wav"), 1,
                            Defines.ATTN_NORM, 0);
                }
            }

            if ((self.spawnflags & 2) != 0) //shoot
            {
            } else if ((self.spawnflags & 4) != 0) //attack
            {
                other.enemy = GameBase.G_PickTarget(self.pathtarget);
                if (other.enemy != null) {
                    other.goalentity = other.enemy;
                    if ((self.spawnflags & 32) != 0)
                        other.monsterinfo.aiflags |= Defines.AI_BRUTAL;
                    if ((self.spawnflags & 16) != 0) {
                        other.monsterinfo.aiflags |= Defines.AI_STAND_GROUND;
                        actor_stand.think(other);
                    } else {
                        actor_run.think(other);
                    }
                }
            }

            if (0 != (self.spawnflags & 6) && (self.pathtarget != null)) {
                String savetarget;

                savetarget = self.target;
                self.target = self.pathtarget;
                GameUtil.G_UseTargets(self, other);
                self.target = savetarget;
            }

            other.movetarget = GameBase.G_PickTarget(self.target);

            if (other.goalentity == null)
                other.goalentity = other.movetarget;

            if (null == other.movetarget && null == other.enemy) {
                other.monsterinfo.pausetime = GameBase.level.time + 100000000;
                other.monsterinfo.stand.think(other);
            } else if (other.movetarget == other.goalentity) {
                Math3D.VectorSubtract(other.movetarget.s.origin,
                        other.s.origin, v);
                other.ideal_yaw = Math3D.vectoyaw(v);
            }
        }
    };

    static void actorMachineGun(edict_t self) {
        float start[] = { 0, 0, 0 }, target[] = { 0, 0, 0 };

        float forward[] = { 0, 0, 0 }, right[] = { 0, 0, 0 };

        Math3D.AngleVectors(self.s.angles, forward, right, null);

        Math3D.G_ProjectSource(self.s.origin,
                M_Flash.monster_flash_offset[Defines.MZ2_ACTOR_MACHINEGUN_1],
                forward, right, start);

        if (self.enemy != null) {
            if (self.enemy.health > 0) {
                Math3D.VectorMA(self.enemy.s.origin, -0.2f,
                        self.enemy.velocity, target);
                target[2] += self.enemy.viewheight;
            } else {
                Math3D.VectorCopy(self.enemy.absmin, target);
                target[2] += (self.enemy.size[2] / 2);
            }
            Math3D.VectorSubtract(target, start, forward);
            Math3D.VectorNormalize(forward);
        } else {
            Math3D.AngleVectors(self.s.angles, forward, null, null);
        }
        Monster.monster_fire_bullet(self, start, forward, 3, 4,
                Defines.DEFAULT_BULLET_HSPREAD, Defines.DEFAULT_BULLET_VSPREAD,
                Defines.MZ2_ACTOR_MACHINEGUN_1);
    }

    /**
     * QUAKED misc_actor (1 .5 0) (-16 -16 -24) (16 16 32)
     */

    public static void SP_misc_actor(edict_t self) {
        if (GameBase.deathmatch.value != 0) {
            GameUtil.G_FreeEdict(self);
            return;
        }

        if (self.targetname != null) {
            GameBase.gi.dprintf("untargeted " + self.classname + " at "
                    + Lib.vtos(self.s.origin) + "\n");
            GameUtil.G_FreeEdict(self);
            return;
        }

        if (self.target != null) {
            GameBase.gi.dprintf(self.classname + " with no target at "
                    + Lib.vtos(self.s.origin) + "\n");
            GameUtil.G_FreeEdict(self);
            return;
        }

        self.movetype = Defines.MOVETYPE_STEP;
        self.solid = Defines.SOLID_BBOX;
        self.s.modelindex = GameBase.gi.modelindex("players/male/tris.md2");
        Math3D.VectorSet(self.mins, -16, -16, -24);
        Math3D.VectorSet(self.maxs, 16, 16, 32);

        if (0 == self.health)
            self.health = 100;
        self.mass = 200;

        self.pain = actor_pain;
        self.die = actor_die;

        self.monsterinfo.stand = actor_stand;
        self.monsterinfo.walk = actor_walk;
        self.monsterinfo.run = actor_run;
        self.monsterinfo.attack = actor_attack;
        self.monsterinfo.melee = null;
        self.monsterinfo.sight = null;

        self.monsterinfo.aiflags |= Defines.AI_GOOD_GUY;

        GameBase.gi.linkentity(self);

        self.monsterinfo.currentmove = actor_move_stand;
        self.monsterinfo.scale = MODEL_SCALE;

        GameAI.walkmonster_start.think(self);

        // actors always start in a dormant state, they *must* be used to get
        // going
        self.use = actor_use;
    }

    public static void SP_target_actor(edict_t self) {
        if (self.targetname != null)
            GameBase.gi.dprintf(self.classname + " with no targetname at "
                    + Lib.vtos(self.s.origin) + " \n");

        self.solid = Defines.SOLID_TRIGGER;
        self.touch = target_actor_touch;
        Math3D.VectorSet(self.mins, -8, -8, -8);
        Math3D.VectorSet(self.maxs, 8, 8, 8);
        self.svflags = Defines.SVF_NOCLIENT;

        if ((self.spawnflags & 1) != 0) {
            if (0 == self.speed)
                self.speed = 200;
            if (0 == GameBase.st.height)
                GameBase.st.height = 200;
            if (self.s.angles[Defines.YAW] == 0)
                self.s.angles[Defines.YAW] = 360;
            GameBase.G_SetMovedir(self.s.angles, self.movedir);
            self.movedir[2] = GameBase.st.height;
        }

        GameBase.gi.linkentity(self);
    }
}